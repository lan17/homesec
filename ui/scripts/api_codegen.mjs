#!/usr/bin/env node

import { spawnSync } from 'node:child_process'
import {
  copyFileSync,
  existsSync,
  mkdirSync,
  mkdtempSync,
  readFileSync,
  rmSync,
  writeFileSync,
} from 'node:fs'
import os from 'node:os'
import path from 'node:path'
import process from 'node:process'
import { fileURLToPath } from 'node:url'

const GENERATED_HEADER = `/*\n * This file is generated by ui/scripts/api_codegen.mjs.\n * Do not edit this file directly.\n */\n`

const __filename = fileURLToPath(import.meta.url)
const scriptsDir = path.dirname(__filename)
const uiRoot = path.resolve(scriptsDir, '..')
const repoRoot = path.resolve(uiRoot, '..')
const generatedDir = path.join(uiRoot, 'src', 'api', 'generated')
const mode = process.argv[2] ?? 'generate'

if (mode !== 'generate' && mode !== 'check') {
  console.error(`Unsupported mode "${mode}". Use "generate" or "check".`)
  process.exit(1)
}

function runCommand(command, args, options = {}) {
  const result = spawnSync(command, args, {
    cwd: options.cwd,
    env: { ...process.env, ...(options.env ?? {}) },
    stdio: options.stdio ?? 'pipe',
    encoding: 'utf-8',
  })

  if (result.error) {
    throw result.error
  }

  if (result.status !== 0 && !options.allowFailure) {
    const output = [result.stdout, result.stderr].filter(Boolean).join('\n')
    throw new Error(
      `Command failed (${command} ${args.join(' ')}):\n${output || '<no output>'}`,
    )
  }

  return result
}

function commandExists(command) {
  if (command.includes('/')) {
    return existsSync(command)
  }
  const result = runCommand('which', [command], {
    allowFailure: true,
  })
  return result.status === 0
}

function readJson(filePath) {
  return JSON.parse(readFileSync(filePath, 'utf-8'))
}

function buildTypesFile({
  cameraSchemaName,
  healthSchemaName,
  statsSchemaName,
  diagnosticsSchemaName,
  clipListSchemaName,
  clipSchemaName,
  clipStatusSchemaName,
}) {
  return `${GENERATED_HEADER}\nimport type { components, paths } from './schema'\n\nexport type OpenAPIComponents = components\nexport type OpenAPIPaths = paths\nexport type CameraResponse = components["schemas"]["${cameraSchemaName}"]\nexport type CameraListResponse = CameraResponse[]\nexport type HealthResponse = components["schemas"]["${healthSchemaName}"]\nexport type StatsResponse = components["schemas"]["${statsSchemaName}"]\nexport type DiagnosticsResponse = components["schemas"]["${diagnosticsSchemaName}"]\nexport type ClipListResponse = components["schemas"]["${clipListSchemaName}"]\nexport type ClipResponse = components["schemas"]["${clipSchemaName}"]\nexport type ClipStatus = components["schemas"]["${clipStatusSchemaName}"]\nexport type ListClipsQuery = NonNullable<paths["/api/v1/clips"]["get"]["parameters"]["query"]>\n`
}

function buildClientFile() {
  return `${GENERATED_HEADER}\nimport type {\n  CameraListResponse,\n  ClipListResponse,\n  ClipResponse,\n  DiagnosticsResponse,\n  HealthResponse,\n  ListClipsQuery,\n  StatsResponse,\n} from './types'\n\nexport interface ApiRequestOptions {\n  signal?: AbortSignal\n  apiKey?: string | null\n}\n\nexport interface GeneratedHomeSecClient {\n  getCameras(options?: ApiRequestOptions): Promise<CameraListResponse>\n  getHealth(options?: ApiRequestOptions): Promise<HealthResponse>\n  getStats(options?: ApiRequestOptions): Promise<StatsResponse>\n  getDiagnostics(options?: ApiRequestOptions): Promise<DiagnosticsResponse>\n  getClips(query?: ListClipsQuery, options?: ApiRequestOptions): Promise<ClipListResponse>\n  getClip(clipId: string, options?: ApiRequestOptions): Promise<ClipResponse>\n}\n`
}

function resolveResponseSchemaName(openapiSchema, { pathName, method, statuses, fallbackSchemaName }) {
  const route = openapiSchema.paths?.[pathName]?.[method]
  if (!route || typeof route !== 'object') {
    throw new Error(`Missing ${method.toUpperCase()} ${pathName} route in exported OpenAPI schema`)
  }

  for (const statusCode of statuses) {
    const schema = route.responses?.[statusCode]?.content?.['application/json']?.schema
    if (schema?.$ref && typeof schema.$ref === 'string') {
      const prefix = '#/components/schemas/'
      if (schema.$ref.startsWith(prefix)) {
        return schema.$ref.slice(prefix.length)
      }
    }
  }

  if (
    typeof fallbackSchemaName === 'string'
    && openapiSchema.components?.schemas?.[fallbackSchemaName]
  ) {
    return fallbackSchemaName
  }

  throw new Error(
    `Unable to derive schema type for ${method.toUpperCase()} ${pathName} from OpenAPI schema`,
  )
}

function generateOpenApiArtifacts(tempGeneratedDir) {
  const openapiJsonPath = path.join(tempGeneratedDir, 'openapi.json')
  const schemaTsPath = path.join(tempGeneratedDir, 'schema.ts')
  const typesTsPath = path.join(tempGeneratedDir, 'types.ts')
  const clientTsPath = path.join(tempGeneratedDir, 'client.ts')

  runCommand(
    'uv',
    ['run', 'python', '-m', 'homesec.api.openapi_export', '--output', openapiJsonPath],
    { cwd: repoRoot },
  )

  const generatorPreference = process.env.HOMESEC_UI_CODEGEN_ENGINE ?? 'auto'
  const speakeasyBin = process.env.SPEAKEASY_BIN ?? 'speakeasy'
  const speakeasyWorkflow = path.join(uiRoot, '.speakeasy', 'workflow.yaml')

  if (generatorPreference !== 'openapi-typescript') {
    const hasSpeakeasy = commandExists(speakeasyBin)
    const hasWorkflow = existsSync(speakeasyWorkflow)
    if (hasSpeakeasy && hasWorkflow) {
      const result = runCommand(speakeasyBin, ['run'], {
        cwd: uiRoot,
        allowFailure: generatorPreference === 'auto',
        stdio: 'inherit',
        env: {
          HOMESEC_OPENAPI_SCHEMA_PATH: openapiJsonPath,
        },
      })

      if (result.status !== 0 && generatorPreference === 'speakeasy') {
        throw new Error('Speakeasy workflow failed with HOMESEC_UI_CODEGEN_ENGINE=speakeasy')
      }
    } else if (generatorPreference === 'speakeasy') {
      throw new Error(
        'Speakeasy requested but binary or workflow is missing. Configure SPEAKEASY_BIN and ui/.speakeasy/workflow.yaml.',
      )
    }
  }

  runCommand(
    'pnpm',
    ['exec', 'openapi-typescript', openapiJsonPath, '--output', schemaTsPath],
    { cwd: uiRoot },
  )

  const schema = readJson(openapiJsonPath)
  if (!schema.components?.schemas?.CameraResponse) {
    throw new Error('Missing CameraResponse schema in exported OpenAPI spec')
  }
  const healthSchemaName = resolveResponseSchemaName(schema, {
    pathName: '/api/v1/health',
    method: 'get',
    statuses: ['200', '503', 'default'],
    fallbackSchemaName: 'HealthResponse',
  })
  const statsSchemaName = resolveResponseSchemaName(schema, {
    pathName: '/api/v1/stats',
    method: 'get',
    statuses: ['200', 'default'],
    fallbackSchemaName: 'StatsResponse',
  })
  const diagnosticsSchemaName = resolveResponseSchemaName(schema, {
    pathName: '/api/v1/diagnostics',
    method: 'get',
    statuses: ['200', 'default'],
    fallbackSchemaName: 'DiagnosticsResponse',
  })
  const clipListSchemaName = resolveResponseSchemaName(schema, {
    pathName: '/api/v1/clips',
    method: 'get',
    statuses: ['200', 'default'],
    fallbackSchemaName: 'ClipListResponse',
  })
  const clipSchemaName = resolveResponseSchemaName(schema, {
    pathName: '/api/v1/clips/{clip_id}',
    method: 'get',
    statuses: ['200', 'default'],
    fallbackSchemaName: 'ClipResponse',
  })
  if (!schema.components?.schemas?.ClipStatus) {
    throw new Error('Missing ClipStatus schema in exported OpenAPI spec')
  }
  writeFileSync(
    typesTsPath,
    buildTypesFile({
      cameraSchemaName: 'CameraResponse',
      healthSchemaName,
      statsSchemaName,
      diagnosticsSchemaName,
      clipListSchemaName,
      clipSchemaName,
      clipStatusSchemaName: 'ClipStatus',
    }),
    'utf-8',
  )
  writeFileSync(clientTsPath, buildClientFile(), 'utf-8')

  return {
    openapiJsonPath,
    schemaTsPath,
    typesTsPath,
    clientTsPath,
  }
}

function filesDiffer(sourcePath, targetPath) {
  if (!existsSync(targetPath)) {
    return true
  }
  return readFileSync(sourcePath, 'utf-8') !== readFileSync(targetPath, 'utf-8')
}

function applyGeneratedFiles(tempFiles) {
  mkdirSync(generatedDir, { recursive: true })

  const artifactMap = {
    'openapi.json': tempFiles.openapiJsonPath,
    'schema.ts': tempFiles.schemaTsPath,
    'types.ts': tempFiles.typesTsPath,
    'client.ts': tempFiles.clientTsPath,
  }

  const changedFiles = []
  for (const [name, sourcePath] of Object.entries(artifactMap)) {
    const targetPath = path.join(generatedDir, name)
    if (filesDiffer(sourcePath, targetPath)) {
      copyFileSync(sourcePath, targetPath)
      changedFiles.push(targetPath)
    }
  }

  return changedFiles
}

function checkGeneratedFiles(tempFiles) {
  const artifactMap = {
    'openapi.json': tempFiles.openapiJsonPath,
    'schema.ts': tempFiles.schemaTsPath,
    'types.ts': tempFiles.typesTsPath,
    'client.ts': tempFiles.clientTsPath,
  }

  const staleFiles = []
  for (const [name, sourcePath] of Object.entries(artifactMap)) {
    const targetPath = path.join(generatedDir, name)
    if (filesDiffer(sourcePath, targetPath)) {
      staleFiles.push(`src/api/generated/${name}`)
    }
  }

  if (staleFiles.length > 0) {
    console.error('Generated API artifacts are stale:')
    for (const fileName of staleFiles) {
      console.error(`  - ${fileName}`)
    }
    console.error('Run `pnpm api:generate` in ui/ and commit the updated files.')
    process.exit(1)
  }
}

function main() {
  const tempRoot = mkdtempSync(path.join(os.tmpdir(), 'homesec-api-codegen-'))
  const tempGeneratedDir = path.join(tempRoot, 'generated')
  mkdirSync(tempGeneratedDir, { recursive: true })

  try {
    const tempFiles = generateOpenApiArtifacts(tempGeneratedDir)

    if (mode === 'generate') {
      const changedFiles = applyGeneratedFiles(tempFiles)
      if (changedFiles.length === 0) {
        console.log('API artifacts are already up to date.')
      } else {
        console.log('Updated generated API artifacts:')
        for (const filePath of changedFiles) {
          console.log(`  - ${path.relative(uiRoot, filePath)}`)
        }
      }
      return
    }

    checkGeneratedFiles(tempFiles)
    console.log('Generated API artifacts are up to date.')
  } finally {
    rmSync(tempRoot, { recursive: true, force: true })
  }
}

main()
